\section{Design and Implementation}

Our system handles lookups at the granularity of resource record sets (RRSets),
as in conventional DNS.
An RRSet is a list of all the records matching a
given domain name and resource type.
For example, at the time of writing, {\em www.nytimes.com}
has three address (A) records: 208.48.26.245, 64.94.185.200,
and 208.48.26.200.  These three answers compose the RRSet
for ({\em www.nytimes.com}, A).

DNSSEC uses public key cryptography to sign resource record
sets.  When we retrieve an RRSet from an arbitrary
DHash server, we need to verify the signature (included as a 
signature (SIG) record).
To find the public key that should have signed the RRSet,
we need to execute another DNS lookup, 
this time for a public key (KEY) RRSet.
This RRSet is in turn signed with the public key for the
enclosing domain.
For example, the ({\em www.nytimes.com}, A) RRSet should
be signed with a key listed in the ({\em www.nytimes.com}, KEY) RRSet.
The latter RRSet should be signed with a key
listed in the ({\em nytimes.com}, KEY)
RRSet, and so on to the hierarchy root,
which has a well-known public key.

DDNS stores and retrieves resource record sets using
DHash~\cite{cfs:sosp01}, a Chord-based distributed hash table.
DHash has two properties useful for this
discussion: load balance and robustness.

DHash uses consistent hashing to allocate keys to nodes evenly.
Further, as each block is retrieved, it is cached along
the lookup path.
If a particular record is looked up $n$ times in succession
starting at random locations in a chord ring of size $m$, then with high probability
each server transfers a given record only $\log{m}$ times total
before every server has the record cached.

DHash is also robust: as servers come and go, DHash automatically
moves data so that it is always stored on a fixed number of replicas
(typically six).  Because the replicas that store a block are chosen
in a pseudo-random fashion, a very large number of servers all have to
fail simultaneously before data loss occurs. 

To create or update a DDNS RRSet, the owner of that set prepares
the RRSet, signs it, and inserts it into DHash marked with type DNS RRSet.
The key for the RRSet is the SHA1 hash of the domain name and the RRSet query type
({\em e.g.}, SHA1({\em www.nytimes.com}, A)).
DHash verifies the signature before accepting the data.
When a client retrieves the RRSet, they also check the signature before using the data.

In the scheme described so far, verifying a DNS RRSet for a name with $n$ 
path elements requires $n$ public key lookups.
To avoid some of this cost, we can optionally
include extra public key RRSets so that all the data needed to verify a record
is attached to the record itself.
This would inflate the size of records somewhat, although
common public keys ({\em e.g.}, the key for {\em .com}) could
be omitted on the assumption that they would be 
widely cached anyway.

To ease transition from conventional DNS to our system,
a simple loopback server listening on 127.1 could accept
conventional DNS queries, perform the appropriate chord lookup,
and then send a conventional response.
Then systems could simply be configured to 
point at 127.1 as their name server.

