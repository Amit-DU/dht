\section{Design and Implementation}

We have implemented a prototype of our system,
which we call DDNS.

Our system handles lookups at the granularity of resource record sets (RRSets),
as in conventional DNS.
An RRSet is a list of all the records matching a
given domain name and resource type.
For example, at the time of writing, {\em www.nytimes.com}
has three address (A) records: 208.48.26.245, 64.94.185.200,
and 208.48.26.200.  These three answers compose the RRSet
for ({\em www.nytimes.com}, A).

DNSSEC uses public key cryptography to sign resource record
sets.  When we retrieve an RRSet from an arbitrary
server, we need to verify the signature (included as a 
signature (SIG) record).
To find the public key that should have signed the RRSet,
we need to execute another DNS lookup, 
this time for a public key (KEY) RRSet.
This RRSet is in turn signed with the public key for the
enclosing domain.
For example, the ({\em www.nytimes.com}, A) RRSet should
be signed with a key listed in the ({\em www.nytimes.com}, KEY) RRSet.
The latter RRSet should be signed with a key
listed in the ({\em nytimes.com}, KEY)
RRSet, and so on to the hierarchy root,
which has a well-known public key.

DDNS stores and retrieves resource record sets using
DHash~\cite{cfs:sosp01}, a Chord-based distributed hash table.
DHash has two properties useful for this
discussion: load balance and robustness.

DHash uses consistent hashing to allocate keys to nodes evenly.
Further, as each block is retrieved, it is cached along
the lookup path.
If a particular record is looked up $n$ times in succession
starting at random locations in a Chord ring of $m$ nodes, 
then with high probability
each server transfers a given record only $\log{m}$ times total
before every server has the record cached.

DHash is also robust: as servers come and go, DHash automatically
moves data so that it is always stored on a fixed number of replicas
(typically six).  Because the replicas that store a block are chosen
in a pseudo-random fashion, a very large number of servers must
fail simultaneously before data loss occurs. 

To create or update a DDNS RRSet, the owner prepares
the RRSet, signs it, and inserts it into DHash.
The key for the RRSet is the SHA1 hash of the domain name and the RRSet query type
({\em e.g.}, SHA1({\em www.nytimes.com}, A)).
DHash verifies the signature before accepting the data.
When a client retrieves the RRSet, it also checks 
the signature before using the data.

Naively verifying a DNS RRSet for a name with $n$ 
path elements requires $n$ KEY lookups.
We address this problem by allowing the owner to
present additional relevant KEYs in the RRSet.
To avoid inflating the responses, we can omit KEY RRSets
for popular names.
For example, the record containing the ({\em www.nytimes.com}, A) RRSet
might also include the ({\em www.nytimes.com}, KEY) RRSet 
and the ({\em nytimes.com}, KEY) RRSet but omit
the ({\em .com}, KEY) RRSet on the assumption that
it would be widely cached.
The key for the root of the hierarchy is assumed to be
known by all DDNS servers, just as the IP addresses of the
root servers are known in the current DNS.

To ease transition from conventional DNS to our system,
a simple loopback server listening on 127.1 could accept
conventional DNS queries, perform the appropriate Chord lookup,
and then send a conventional response.
Then systems could simply be configured to 
point at 127.1 as their name server.

