\section{Design}

DDNS makes use of
DHash~\cite{cfs:sosp01}, a distributed hash table
built on top of Chord, to store
and retrieve resource records (RRs).
Dhash has the following two nice properties:

\begin{list}{$\bullet$}{}
\item {\em Load balance}.
For normal records, DHash uses consistent hashing 
(through Chord) to allocate keys to nodes evenly.
For popular records, DHash employs caching to even out
the load. If a particular record is looked up $n$ times
in succession by different hosts (where $n$ can be very large),
then with high probability each server serves a given record 
only $\log{m}$ times in total, 
where $m$ is the number of servers. Notice that
the number of times a record is transferred is 
{\it independent} of how popular it is. 

\item {\em Robustness}.
As servers are disconnected from and reconnected to the network,
DHash automatically moves data so that it is always on a fixed
number of available replicas (typically six).
Further, a very large number of servers have to
all be disconnected simultaneously before data loss
becomes apparent.
\end{list}

\subsection{Resource Records}

All RRs for a domain name and record type pair are stored 
as a single record (RRSet)
indexed by {\tt <domain name, type>}.
All transactions are done on the granularity
of RRSets. The reason for grouping RRs is because it 1)
guarantees that all RRs for a {\tt <domain name, type>} will reside on
the same server, 2) complements the verification scheme
of DNSSEC, and 3) results in a simple
and functional design altogether. Most lookups will specify
a name accompanied by a type, so a typical DNS lookup will only need
to retrieve data from one server.

\subsection{Stores}

To store a DDNS record, the owner of that record 
assembles all the RRs associated with the domain name and type,
and sends a {\tt ddns-store(name, type, RRSet)} message to DDNS. 
DDNS calculates the hash of the {\tt <domain name, type>} and sends
a {\tt dhash-store(hash, data)} RPC to DHash, using the
RRSet as the data.

\subsection{Lookups}

To perform a DNS lookup, a client will send a 
{\tt ddns-lookup(name, type)} message to {DDNS}.
DDNS 
calculates the hash of the {\tt <domain name, type>} sends a
{\tt dhash-lookup(hash)} RPC to DHash. Upon receiving
the response, DDNS returns the corresponding RRSet to the 
client or report an error of the {\tt <domain name, type>} does 
not exist. Once a lookup request is sent to DDNS, it will 
always return an answer, whether it be positive or not. 
This is because DDNS does not depend on the information 
in the {\tt NS}-record to track down the information for a key.
If a {\tt <domain name, type>} does not exist in the DDNS database,
then its RRSet does not exist in DNS.

\subsection{DDNS Record Verification}

Since records are being served from arbitrary hosts rather
than the hosts responsible for the domain, 
we use authentication scheme in 
DNS Security Extensions (DNSSEC)~\cite{dnssec:rfc} to
verify all records before returning them. DNSSEC stores the 
signature of the owner of an RRSet in a SIG RR. Every RRSet
includes a SIG RR corresponding to it. Keys for a domain can 
be retrieved via a lookup for the KEY RR, which is treated 
like any other RR type, except that it is signed with the 
key of the higher-level domain.
 
% We use one {\tt SIG RR} to carry the owner's signature
% of the entire DDNS record, since we always transmit data on
% the granularity of DDNS records.
