\section{Implementation}

\begin{figure}
\psfig{figure=system.eps,height=2in}
\caption{System Overview}
\label{fig:system}
\end{figure}

\subsection{Clients to DDNS}

DDNS is designed to work with existing DNS resolvers. 
An application wishing to lookup a domain name calls
the usual utility function (eg. {\tt gethostbyname()}). 
The file which contains name servers to contact 
(eg. {\tt /etc/resolv.conf}) is different, however.
It will initially have one (or a few) IP address of
a server participating in the DDNS system. The stub 
resolver program sends requests to those servers,
which translate requests into DDNS lookups,
and pass them to the DDNS daemon.
To prevent the case where the few servers on the 
{\tt /etc/resolv.conf} list are down, separate process 
running on the client machine will fill the list with
more DDNS servers (through communication with the initial
servers on the list). The probability of all servers
on the list going down is very small.

\subsection{DDNS Server}

XXX Revise XXXX\\
We plan to set up a DDNS server, running DDNS daemons,
to serve some information for personal domains.
The only difficult part about this is starting the signature
verification tree, since the root servers don't store public
key information. (For the purposes of our experiments,
we will invent a ``well-known'' public key for the DNS root.)
To bootstrap ourselves,
the NS record for a given domain to be served
by Chord will contain a SHA1 cryptographic hash of the
public key for that domain.
For example, the NS record for {\tt uvxyz.org}
is {\tt 551cdc73ac64e15193eeab47bf0f3fab8c118fd6
.chorddns.net}
with a glue record translating this fake name to a real IP address.
When a DDNS daemon receives a request for {\tt host.dom.uvxyz.org},
it queries the root server to find the public key hash,
performs a DHash lookup to find the DDNS record for 
{\tt host.dom.uvxyz.org},
and then verifies it starting with the {\tt uvxyz.org} root.

