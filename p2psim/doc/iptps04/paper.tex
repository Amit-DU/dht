% Headers {{{1
\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{url,graphicx,epsfig,alltt,fancybox}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[colorlinks,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}

\title{\Large \bf Snore: the peer-to-peer simulator we were all waiting for}
\author{Zeeb and Zoob \\
{\em CSAIL, M.I.T., Cambridge, MA} \\
{\tt \{zeeb,zoob\}@csail.mit.edu}}
\date{}
\begin{document}
\maketitle

% 1}}}
% Abstract {{{1
\begin{abstract}
\end{abstract}

We want to dominate the world, so everyone should use Snore.

% 1}}}
% Introduction {{{1
\thispagestyle{empty}
\section{Introduction}
\label{Section:Introduction}

A large number of P2P protocols have been proposed in the literature.  There
is no unified framework for evaluating the performance of these protocols.
Deploying in real-world network can be complex and depending on the comparison
you wish to do, not even useful.

We're trying to encourage P2P research community to all use the same
simulator base, to save work, to make it easier to reproduce each
other's results, to make it easier to compare different ideas.

Framework for comparing P2P protocols.  Should allow for easy coding of
protocols and simple models for underlying topologies.  Preferably, allow for
pseudo code to be written, abstracting away all the intricacies of network
protocols, etc.

Key goal: direct use of pseudo-code. Ha ha. Realistically, be able to
get off the ground with straight pseudo-code, evolve gradually. Key
consequence: we need threads.

Want the simulator to make it easy to trying out new ideas.

Need to be able to claim that the simulation needs of P2P protocols
are different from those of lower-level protocols.

Make it easy to compare different P2P algorithms.

Challenges: scaling.

Why is this a reasonable thing to do?  Not oversimplified?  Results correspond
with real life!

Want to draw contrast to only doing real implementations (hard to
evaluate different choices or uncommon situations or large scale), and
contrast to everyone writing their own incompatible simulation.

% 1}}}
% Related work {{{1
\section{Related work}
\label{Section:Related}

Why not NS? 1) It doesn't have threads. 2) We believed we could make a
much simpler framework given what we were simulating. Latency only,
simple RPCs, don't need complex topology, don't need TCP.

Other simulators suck.

% 1}}}
% Design considerations {{{1
\section{Design considerations}
\label{Section:Design}

Key design ideas. Want to be able to combine any combination of
algorithm, workload (events file), and topology. And we want these
three ideas to be orthogonal.

What's an algorithm? What do you have to define? What's the interface
to the rest of the system?

What's a workload? Interface? Typical examples? (It would be nice if
there were an Application class, orthogonal to Protocol, that allowed
any Application to run with any Protocol. So you could run DHash on
top of Pastry.)

What's a topology? Interface? Typical examples?

Open issues: maybe it's impossible to define a useful
Application/Protocol interface that would let any App run with any
Protocol. A full ``workload'' includes crashes/joins, which it's not
clear it makes send to mix in with the Application operations like
lookup. Where does e.g. Vivaldi fit in.

% }}}1
% Implementation {{{1
\section{Implementation}
\label{Section:Implementation}

Which protocols supported.  How many lines of code for each compared to the
real thing?  How easy was it to take pseudocode and dump it in the simulator.

Russ' threads package allows for simple coding.

% }}}1
% Experiments {{{1
\section{Experiments}
\label{Section:Experiments}

Number of threads.  Number of nodes.  How many messages can we deliver to
nodes per second, or something like that.

Show that numbers that come out have some correspondence to the real world.
Topology models are OK, demonstrate with King data set.

Where is the bottleneck?

[Must hack simulator to reduce threads.]


% 1}}}
% Conclusion {{{1
\section{Conclusion}
\label{Section:Conclusion}

% 1}}}
% Acknowledgements {{{1
\section{Acknowledgements}
\label{Section:Acknowledgements}

\vfill

% 1}}}
% Bibliography {{{1
\pagebreak

% \begin{flushleft}
% % \bibliographystyle{alpha}
% % \bibliography{paper}
% \end{flushleft}

\end{document}
% 1}}}
% vim: set foldlevel=0 fen:
